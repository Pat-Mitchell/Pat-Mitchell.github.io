article = {
  author:`Pat Mitchell`,
  date:`Saturday August 24, 2022`,
  previousArticle:`canvas1`,
  previousArticleTitle:`Using the HTML canvas`,
  nextArticle:null,
  nextArticleTitle:null,
  title:`Moving to WebGL`,
  body:`
  <p>WebGL (Web Graphics Library) is the next step in learning computer
  graphics. It is still possible to continue learning with the &#60;canvas&#62;'s
  2D context, however there's a major bottleneck in performance when using only
  the CPU for drawing to the screen. Per-pixel manipulation is very slow and
  "creative" solutions are required to improve performance like using multiple
  &#60;canvas&#62; elements for static elements like ui and predrawing scrolling
  backgrounds.</p>

  <figure id="figure1">
    <canvas id="webgl1" width="300" height="300"></canvas>
    <figcaption>Figure 1: Drawing a single point to the canvas.</figcaption>
  </figure>

  <p>WebGL offloads the work from the CPU to the GPU and the API decreases
  developer time (which is at a very high premium when some projects are
  almost exclusively worked on during lunch breaks). There's also additional
  marketing benefits for myself having experience with GLSL (OpenGL Shading
  Language), which is used in both WebGL and OpenGL applications.</p>

  <p>To learn how to use the webGL context, I picked up a copy of WebGL
  Programming Guide by Kouichi Matsuda and Podger Lea. The examples I have
  on this page are derived from the book. Some changes were made to the
  example code from the book because it was first written in 2013 and
  Javascript has gotten several updates since. For example the keyword "let"
  replaces most instances of "var" when defining variables because "var" defines
  globally and creates a high risk of name collision.</p>

  <p>Figure 1 displays the "Hello, World!" of WebGL. Drawing a point to the
  screen is a fantastic first program to begin with for understanding how to
  initialize a &#60;canvas&#62; with WebGL and learning the basics of the
  vertex and fragment shaders.</p>

  <figure id="figure2">
    <canvas id="webgl2" width="300" height="300"></canvas>
    <div>
      <button type="button" onclick="up()" id="btnUp">UP</button>
      <button type="button" onclick="down()" id="btnDown">DOWN</button>
      <button type="button" onclick="right()" id="btnRight">RIGHT</button>
      <button type="button" onclick="left()" id="btnLeft">LEFT</button>
      <button type="button" onclick="rotFaster()" id="btnFaster">FASTER</button>
      <button type="button" onclick="rotSlower()" id="btnSlower">SLOWER</button>
    </div>
    <figcaption>Figure 2: Rotating triangle with buttons.</figcaption>
  </figure>

  <p>Figure 2 displays a colorful rotating triangle who's position and rotation
  speed can be adjusted by the user using the buttons uder the figure. Using
  the GLSL shader programming language makes shading a lot faster and easier.
  I had originally impleted vertex based shading in my 2D contex computer graphics
  engine. However, I felt that interpolating the color of each fragment using
  barycentric coordinates would have impacted performance too much and settled
  for a flat shader where each tri had a single color instead of each vertex.</p>

  <p>Figure 2 also doesn't appear in the WebGL book exactly as shown here. The
  original example is a spinning red triangle instead of a multi-colored one.
  I felt it necessary to combine concepts taught in multiple chapters to
  show that I can do more than just copy straight from the book. The book example
  is just an equilateral solid red triangle while this one is varies the color
  based on where the fragment is in relation to the vertices and positions of the
  vertices are scaled 150% in the x direction and 75% in the y direction.</p>

  <figure id="figure3">
    <canvas id="webgl3" width="300" height="300"></canvas>
    <figcaption>Figure 3: Click and draggable lighted cube.</figcaption>
  </figure>

  <p>Figure 3 displays another interactive canvas with a textured cube and
  in directional lighting. The rgb values of the light are being controled
  by three sinusoid functions out of phase with eachother by 2/3 Pi. It's
  another modified example from the book. The original example was only about
  putting a texture on a model and how GLSL uses a separate coodinate system
  for texels. The lighting was taken from another chapter where the examples
  were only single colored cubes or a sphere.</p>

  <p>The changing light was just a curiousity. The book did not go over shaping
  functions for shading. There was one early example of linear shading based on
  the fragment's x and y values on the canvas, but that was to show off WebGL's
  coordinate system. Sinusoidal functions seemed easy enough to implement to
  change the color over time. Each rgb value is out of phase with the other
  two by &#177;2/3 Pi so there's always at least one color on at any time and
  any rgb negative rgb value is read as 0.0.</p>

  <figure id="figure4">
    <canvas id="webgl4" width="300" height="300"></canvas>
    <figcaption>Figure 4: Cube in fog.</figcaption>
  </figure>
  `,
};
